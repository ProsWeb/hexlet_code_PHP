<!-- Поиск пересечения двух неотсортированных массивов, 
операция в рамках которой выполняется вложенный цикл 
с полной поверкой каждого элемента первого массива, на вхождение во второй. 
Сложность данного алгоритма O(nm) (проивезедение n и m), где n и m размерности массивов. 
Если массивы отсортированы, то можно реализовать алгоритм, сложность которого уже O(n + m), 
что значительно лучше. 
Суть алгоритма довольно проста. В коде вводятся два указателя (индекса) на каждый из массивов. 
Начальное значение каждого указателя 0. Затем идет проверка элементов находящихся 
под этими индексами в обоих массивах. Если они совпадают то значение заносится в 
результирующий массив, а оба индекса инкрементируются, если значение в первом массиве 
больше чем во втором, то инкрементируется указатель второго массива, иначе первого.

src\Arrays.php
Реализуйте функцию getIntersectionForSortedArray, 
которая принимает на вход два отсортированных массива и находит их пересечение.


getIntersectionOfSortedArray([10, 11, 24], [10, 13, 14, 18, 24, 30]);
// => [10, 24]
Подсказки
Для данной задачи хорошо подходит цикл do..while.
Не забудьте поставить проверку на размерность массивов. 
Если хотя бы один из них пустой, то пересечений нет. -->

<?php

// function getIntersectionOfSortedArray($arr1, $arr2)
// {
//     // BEGIN (write your solution here)
//     if (empty($arr1) || empty($arr2)) {
//         return [];
//     }
//     $unionArray = [];
//     for ($i = 0; $i < sizeof($arr1); $i++) {
//         $cur1 = $arr1[$i];
//         if (in_array($cur1, $arr2)) {
//             $unionArray[] = $cur1;
//         }
//     }
//     return $unionArray;

//     // END
// }

function getIntersectionOfSortedArray($arr1, $arr2)
{
    return array_values(array_intersect($arr1, $arr2));
}